# Créer une stack de supervision avec les manifrest kubernetes

Kubernetes permet de déployer des ressources à partir de fichier YAML appelé manifest.

Un manifest peut contenir plusieurs ressources pour constituer une stack logique.

Ce TP à pour objectif :

- Apprendre à déployer une stack
- Comprendre la relation entre les différents Pods
- Comprendre comment le service et les Pods sont reliés

Let's go

## Sources

https://devopscube.com/node-exporter-kubernetes/
https://blog.stephane-robert.info/post/monitoring-kubernetes-k3s-prometheus-grafana/

## Créer un namespace dédié

Créer un namespace permet d'isoler logiquemment une partie des objets, pour la sécurité ou pour la logique. Il sera par exemple possible d'appliquer des règles d'accès ou de monitoring à un namespace en particulier.

```Shell
kubectl create ns monitoring
kubectl config set-context --current --namespace=monitoring
``` 

La deuxième commande permet de se positionner sur le namespace monitoring au lieu de le taper à chaque fois dans les commandes.

# L'appproche manifest

Il est donc possible et même conseillé de créer les ressources avec des manifests. Par comparaison, voici un manifest qui permet de créer un namespace. C'est un fichier  YAML avec quelques particularités :

Fichier namespace.yaml

```YAML
apiVersion: v1
kind: Namespace
metadata:
  name: monitoring
``` 

Ce manifest est simple mais contient le strict essentiel :

- apiVersion: désigne la version de l'API compatible. Attention la valeur change en fonction des fonctinnonalités utilisée
- kind: le type de ressource à créer comme Pod ou Deployment
- metadata: les informations sur l'objet comme son nom, les labels ou annotations

Pour executer ce manifest, on utilise "apply"  : 

```Shell
$ kubectl apply -f namespace.yaml
$ namespace/monitoring created
```

NOTE: le cluster prendra en compte un manifest dont la syntaxe est valide mais ne vérifie pas la cohérence des données.

## Déployer Prometheus

Un déploiement basique implique uniquement un objet Deployment. Cependant, il faudra créer d'autres ressources pour que prometheus puisse évoluer et travailler : 

- un objet "ConfigMap" : il permet d'injecter un fichier de configuration dans un Pod. On injectera donc la configuration de prometheus pour la faire évoluer.
- un objet "RBAC" : il va donner des droits d'accès au namespace pour que Prometheus puisse contacter l'API de Kubernetes.

### Créer le ConfigMap

Pour commencer, nous utilisons une configuration pour que prometheus se monitor lui-même. On créer un manifest pour le définir

Fichier prometheus-configmap.yaml

```YAML
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-server-conf
  labels:
    name: prometheus-server-conf
    stack: monitoring
  namespace: monitoring
data:
  prometheus.yaml: |-
    global:
      scrape_interval:     15s # By default, scrape targets every 15 seconds.

      # Attach these labels to any time series or alerts when communicating with
      # external systems (federation, remote storage, Alertmanager).
      external_labels:
        monitor: 'codelab-monitor'

    # A scrape configuration containing exactly one endpoint to scrape:
    # Here it's Prometheus itself.
    scrape_configs:
      # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
      - job_name: 'prometheus'

        # Override the global default and scrape targets from this job every 5 seconds.
        scrape_interval: 5s

        static_configs:
          - targets: ['localhost:9090']

```
Ce manifest contient toujours la partie metadata et une partie data. dans data, ii peut y avoir plusieurs clé/valeur. Dans cet exemple, il y a une clé et une valeur. La clé doit être le nom du fichier que kubernetes doit créer pour l'associer au Pod. La valeur est le contenu du fichier. Lee sigle "|-" indique que la valeur est sur plusieurs lignes.

NOTE : attention à l'indentation, le contenu est toujours indenté par rapport au nom de la clé.

Executons le manifest et vérifions sa création :

```Shell
$ kubectl apply -f supervision/manifests/prometheus-configmap.yaml 
$ configmap/prometheus-server-conf created
$ kubectl get cm
``` 

NOTE : "kubectl get cm" est une notation raccourci pour "kubectl get configmap". Tous les types d'objet ont un raccourci. voir cette source : https://gist.github.com/piotrpersona/abc28ed2c251c71127bd7d15300f2ae5 

### Déployer prometheus

Le fichier prometheus.yaml

```YAML
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus-deployment
  namespace: monitoring
  labels:
    app: prometheus-server
    stack: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus-server
  template:
    metadata:
      labels:
        app: prometheus-server
    spec:
      containers:
        - name: prometheus
          image: prom/prometheus
          args:
            # - "--storage.tsdb.retention.time=12h"
            - "--config.file=/etc/prometheus/prometheus.yml"
            #- "--storage.tsdb.path=/prometheus/"
          ports:
            - containerPort: 9090
          resources:
            requests:
              cpu: 500m
              memory: 500M
            limits:
              cpu: 1
              memory: 1Gi
          volumeMounts:
            - name: prometheus-config-volume
              mountPath: /etc/prometheus/
            - name: prometheus-storage-volume
              mountPath: /prometheus/
      volumes:
        - name: prometheus-config-volume
          configMap:
            defaultMode: 420
            name: prometheus-server-conf
  
        - name: prometheus-storage-volume
          emptyDir: {}
```

Les notions importantes : 

- selector et matchLabels : les labels sont des clés/valeurs qui sont attachées aux objets pour les identifier et/ou les réunir. Contrairement au identifiant (name) les labels ne représentent pas une ressources unique mais des ressources qui ont même fonction ou la même appartenance. Les selectors vont permettre à des ressources de repérer d'autres objets. Ici le deployment a un selector sur un label et il trouvera tous les pods qui ont ce label pour déterminer par exemple si le bon nombre de Pods est présent.


- Les volumes : la section est divisé en deux parties : les volumesMounts et les volumes. on peut remarquer que le nom du volume est le même dans les deux section, c'est ce qui assure la relation. "defaultMode" est une représentation décimal des droits linux

Déployons la ressource : 

```Shell
$ kubectl apply -f supervision/manifests/prometheus.yaml 
$ deployment.apps/prometheus-deployment created
```

Et vérifions que cela se déroule bien : 

```Shell
$ kubectl get pods


NAME                                     READY   STATUS    RESTARTS        AGE
prometheus-deployment-674dccf59c-ggpsj   1/1     Running   7 (7m32s ago)   13m
```

Ce Pod n'est pas encore joignable, il va faloir l'exposer pour que le traffic puisse être acheminer. C'est le rôle d'un Service. Le service va devoir trouver les Pods par selector en cherchant le label concerné

Par défault, un serveur Prometheus utilise le port 9090, voici un exemple de configuration de service : 

```Yaml
apiVersion: v1
kind: Service
metadata:
  name: prometheus-service
  namespace: monitoring
  annotations:
      prometheus.io/scrape: 'true'
      prometheus.io/port:   '9090'
spec:
  selector: 
    app: prometheus-server
  type: ClusterIP  
  ports:
    - port: 9090
      targetPort: 9090
```

La relation est assuré par le label "app: prometheus-server" qui est positionné sur chaque Pod.

Déployons ce service 

```Shell
$ kubectl apply -f prometheus-service.yaml
$ service/prometheus-service created
```

Vérifions et connectons nous au port : 

```Shell
$ kubectl get svc
NAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
prometheus-service   ClusterIP   10.104.136.214   <none>        9090/TCP   98s

$ kubectl port-forward service/prometheus-service 9090:9090
Forwarding from 127.0.0.1:9090 -> 9090
Forwarding from [::1]:9090 -> 9090
```

En ouvrant le navigateur, Prometheus devrait être fonctionnel à l'adresse http://localhost:9090
